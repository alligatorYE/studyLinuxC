[TOC]

# 嵌入式0x10个问题

## 1.用预处理指令#define声明一 个常数，用以表明1年中有多少秒(忽略闰年问题)

> #define 宏名 宏体
> 宏名：大写字母表示
> ```c
> #define SECOND_OF_YEAR （365 * 24 * 3600）UL
> ```
> 
> 
> 
> 
> L表示长整型//因为可能CPU位数不一样，至少保证为4字节
> U表示无符号
> 
> int a = SECOND_OF_YEAR;//编译阶段已经处理为常数
> 
> ①#define语法的基本知识（例如：不能以分号结束、括号的使用，等等）
> ②懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
> ③意识到这个表达式将使一个16位机的整型数溢出，因此要用到长整型符号L，告诉编译器这个常数是的长整型数。
> ④如果你在你的表达式中用到UL（表示无符号长整型）.

## 2.数据声明：用变量a给出下面的定义

###  ①一个整型数（An integer）；

 ```c 
 int a;
 ```

### ②一个指向整型数的指针（A pointer to an integer）；

 ```c
 int *a;
 ```

### ③一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）；

  ```c
  int **a;
  ```

### ④一个有10个整型数的数组（An array of 10 integers）；

 ```c
 int a[10];
 ```

### ⑤一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）；
 ```c
 int *a[10];
 ```

### ⑥一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）；
 ```c
 int (*a)[10];
 ```

### ⑦一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）；
 ```c
 int (*a)(int)
 ```
### ⑧一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）
 ```c
 int (*a[10]) (int)
 ```

## 3.修饰符

### auto

> 默认情况下都是auto，分配的内存可读可写
> 如果在{}里面，则分配在栈空间

### register

> 限制变量定义在寄存器上的修饰符
> **register int a;**
> 编译器尽量安排CPU的寄存器存放a，如果寄存器不足，依然放在内存中
> &符号对register型变量不起作用

### static
#### 1.修饰局部变量

> 默认局部变量存在于栈
> 加上ststic就局部静态化，局部变量存在于静态数据段保存

#### 2.修饰全局变量

> 防止重命名，加上static则作用于只在本文件.c内。

#### 3.修饰全局函数

> 限制该函数只在本文件中使用

### const

 ```c
const int a = 100; // a是变量，尽量保持100不变，可通过指针修改
 ```
① 只读，建议性，不具备强制性 !=常量
const意味着“只读”
 ```c
const int a;
int const a;
 ```
② 前两个的作用是一样，a是一个常整型数。
 ```c
const int *a;
 ```
③ 意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。
 ```c
int * const a;
 ```
④ a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。
 ```c
int const * a const;
 ```
⑤a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。

合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

### volatile

***告知编译器编译方法的关键字，不优化编译***
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。**精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。**

```c
int a = 100;
while(a == 100)
	LCD();
----------------------
f1: LDR R0,[a]
f2: CMP R0.#100
f3: JMP f1   ------->f2
f4: LCD(); 
```

> 如果将编译器优化，那么cpu与内存和cpu和寄存器比较，cpu与内存速度慢，就会跳转到
> f2,此时a的值去改变程序也不会拿到这个值。
> 因此需要将a用volatile修饰。
