

# C语言跟C++的本质区别

## 1、C语言跟C++的关系
1）c更倾向于面向过程，c++是面向过程+面向对象+泛型编程

2）c解决问题的思路如何通过一个过程来实现我们想要的功能，更注重的是算法；c++是先构造一个对象模型，然后通过调用成员函数来实现相应的功能

3）C和C++动态管理内存的方法不一样，C是使用malloc/free，而C++除此之外还有new/delete关键字。

4）C++支持函数重载，C不支持函数重载 

5）C++中有引用，C中不存在引用的概念



### C语言跟C++的结构体区别：

1）c的结构体不能定义函数，但c++的可以

2）c的空结构体大小为0，c++的为1



### C++如何调用c库函数:

1） 在c库的.h文件中对于函数的声明前要加extern "C",告诉g++不要对以下的函数名重命名

2）如何区分此时用的是g++还是gcc？（1、g++中有__cplusplus这个宏，gcc没有；2、sizeof(‘字符常量’)g++结果是1，gcc是4）。

## 2、面向对象技术的基本概念和基本特征是什么

1. 基本概念：类、对象、继承； 
2. 基本特征：封装、继承、多态。
3. 封装：将低层次的元素组合起来形成新的、更高实体的技术；
4. 继承：广义的继承有三种实现形式：实现继承、可视继承、接口继承。
5. 多态：多态性是允许将父对象设置成为一个或更多的他的子对象相等的技术,简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

## 3、C++空类默认有哪些成员函数？

默认构造函数、析构函数、复制构造函数、赋值函数

## 4、malloc和free、new和delete的问题

### malloc和free、new和delete的区别：

1. malloc和free是标准c库的函数，new和delete是c++的运算符
2. malloc需要强制类型转换，而new不需要
3. malloc需要计算开辟空间的大小，而new不需要

### 为什么有了malloc和free，还要有new和delete？

因为malloc和free是c库函数，不会自动调用构造和析构，而new和delete会。这样就会产生内存泄漏。

## 5、引用和指针的区别

### 本质区别：

引用是变量的别名，是直接访问变量，指针存放的是变量的地址，需要单独开辟空间，访问变量是间接访问



### 形式上的不同：

1. 引用不开辟空间，指针开辟空间
2. 引用必须初始化，指针可以不用初始化
3. 引用自加是变量自加，指针自加表示指针向地址增大的方向移动了一个数据
4. 指针可以赋值为NULL，但引用没有
5. 有void *类型的指针，但是没有void类型的引用
6. 指针有二级指针，但引用没有
7. 指针有函数指针、数组指针，但引用没有
8. 指针只能指向字符串常量，但常引用可以是任何类型常量的别名
9. 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名

10. 指针可以有多级，引用只有一级

11. 指针可以为空，引用不能为NULL且在定义时必须初始化

12. 指针在初始化后可以改变指向，而引用在初始化之后不可再改变

13. sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小

14. 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。

15. 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。

16. 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。

17. 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。

18. 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。

## 6、static的作用

### 在C语言：

修饰局部变量延长了生命周期

修饰全局变量限制了作用域；修饰函数限制了作用域



### 在c++:

#### 修饰成员变量：

1. 类内声明类外定义，因为static修饰的成员变量在编译阶段就开辟了空间，而类的定义不开辟空间，声明不开辟空间。
2. 属于整个类，所有对象共享；先于对象而存在 。
3. 如果是私有的，可以通过留static的成员函数作为公有的接口，在类外直接通过类名访问。
4. 如果是公有的，可以直接在类外通过类名::被访问。



#### 修饰成员函数：

1. 可以直接通过类名加作用域访问
2. 没有this指针，不能访问非静态成员
3. 非静态的成员函数可以访问静态成员

## 7、const的作用

### 在C++中：

#### const修饰成员函数：

1. const修饰的成员函数中不能修改任何成员变量的值
2. Const看似在修饰成员函数，实则是在修饰这个成员函数的第一个形参this
3. 常成员函数只能调用常成员函数

#### const修饰的对象：

1. 不能作为左值
2. 只能调用const修饰的成员函数
3. 不能修改成员变量的值

#### 在C语言中：

1. 对变量声明只读特性，保护变量值以防被修改。
2. 节省空间，避免不必要的内存分配。const修饰的变量在程序运行过程中只有一份拷贝。

## 8、重载、覆盖、重写的区别

1. **重载：** 功能类似，函数名相同，参数不同（个数和类型），与返回值无关

   特征：相同范围（同一个类中）、函数名字相同、参数不同、virtual关键字可有可无

2. **覆盖：** 子类覆盖父类的虚函数，实现接口的重用

   特征：不同范围（基类和派生类）、函数名字相同、参数相同、基类中必须有virtual关键字（必须是虚函数）

3. **重写：** 子类定义了与父类一模一样的虚函数

   特征：不同范围（父类和子类）、函数名字相同、参数不同或者参数相同且无virtual关键字 

## 9、虚函数是怎么实现的

1. 每一个含有虚函数的类都至少有有一个与之对应的虚函数表，其中存放着该类所有虚函数对应的函数指针（地址），
2. 类的示例对象不包含虚函数表，只有虚指针；
3. 派生类会生成一个兼容基类的虚函数表。

## 10、什么情况下会调用拷贝构造函数（三种情况）

1. 用类的一个对象去初始化另一个对象的时候
2. 当函数的参数是类的对象时，就是值传递的时候，如果是引用传递则不会调用
3. 当函数的返回值是类的对象或者引用的时候

## 11、关于sizeof的小结

1. sizeof不计算static变量占得内存；
2. 指针的大小一定是4个字节，而不管是什么类型的指针；
3. char型占1个字节，int占4个字节，short int占2个字节,long int占4个字节，float占4字节，double占48字节，string占4字节,一个空类占1个字节，单一继承的空类占1个字节，虚继承涉及到虚指针所以占4个字节
4. 数组的长度：若指定了数组长度，则不看元素个数，总字节数=数组长度*sizeof（元素类型）,若没有指定长度，则按实际元素个数来确定。Ps：若是字符数组，则应考虑末尾的空字符。
5. 结构体对象的长度：在默认情况下，为方便对结构体内元素的访问和管理，当结构体内元素长度小于处理器位数的时候，便以结构体内最长的数据元素的长度为对齐单位，即为其整数倍。若结构体内元素长度大于处理器位数则以处理器位数为单位对齐。
6. unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）=4
7. 自定义类型的sizeof取值等于它的类型原型取sizeof对函数使用sizeof，在编译阶段会被函数的返回值的类型代替sizeof后如果是类型名则必须加括号，如果是变量名可以不加括号，这是因为sizeof是运算符
8. 当使用结构类型或者变量时，sizeof返回实际的大小。当使用静态数组时返回数组的全部大小，sizeof不能返回动态数组或者外部数组的尺寸 

## 12、sizeof与strlen的区别

1. sizeof的返回值类型为size_t（unsigned int）；
2. sizeof是运算符,而strlen是函数；
3. sizeof可以用类型做参数，其参数可以是任意类型的或者是变量、函数，而strlen只能用char*做参数，且必须是以’\0’结尾；
4. 数组作sizeof的参数时不会退化为指针，而传递给strlen是就退化为指针；
5. sizeof是编译时的常量，而strlen要到运行时才会计算出来，且是字符串中字符的个数而不是内存大小；

## 13、sizeof与strlen的区别

1. sizeof的返回值类型为size_t（unsigned int）；
2. sizeof是运算符,而strlen是函数；
3. sizeof可以用类型做参数，其参数可以是任意类型的或者是变量、函数，而strlen只能用char*做参数，且必须是以’\0’结尾；
4. 数组作sizeof的参数时不会退化为指针，而传递给strlen是就退化为指针；
5. sizeof是编译时的常量，而strlen要到运行时才会计算出来，且是字符串中字符的个数而不是内存大小；

## 14、数组和指针的区别

1.  数组要么在全局数据区被创建，要么在栈上被创建；指针可以随时指向任意类型的内存块；

2.  修改内容上的差别：

 

```C
char a[] = “hello”;
a[0] = ‘X’;
char *p = “world”; // 注意p 指向常量字符串
p[0] = ‘X’; // 编译器不能发现该错误，运行时错误
```

3. 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。

## 15、结构体内存对齐问题

1. 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。

2. 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）

   

## 16、头文件中的ifndef/define/endif有什么作用

前者是从标准库路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。

## 17、什么是智能指针

1. 当类中有指针成员时，一般有两种方式来管理指针成员：一是采用值型的方式管理，每个类对象都保留一份指针指向的对象的拷贝；另一种更优雅的方式是使用智能指针，从而实现指针指向的对象的共享,可以有效避免悬垂指针
2. 智能指针的一种通用实现技术是使用#引用计数#。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。
3. 每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）

## 18、实例之间共享的变量是什么变量

static静态成员变量。不属于某一个对象，而属于一个类。

## 19、继承层次中，为什么基类析构函数是虚函数

编译器总是根据类型来调用类成员函数。但是一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于派生类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。

## 20、为什么构造函数不能为虚函数

虚函数采用一种虚调用的方法。需调用是一种可以在只有部分信息的情况下工作的机制。如果创建一个对象，则需要知道对象的准确类型，因此构造函数不能为虚函数。

## 21、如果虚函数是有效的，那为什么不把所有函数设为虚函数

不行。首先，虚函数是有代价的，由于每个虚函数的对象都要维护一个虚函数表，因此在使用虚函数的时候都会产生一定的系统开销，这是没有必要的。

## 22、公有继承、受保护继承、私有继承主要区别

1. 公有继承时，派生类对象可以访问基类中的公有成员，派生类的成员函数可以访问基类中的公有和受保护成员；
2. 私有继承时，基类的成员只能被直接派生类的成员访问，无法再往下继承；
3. 受保护继承时，基类的成员也只被直接派生类的成员访问，无法再往下继承。

## 23、const和#define有什么区别

1. const和#define都可以定义常量，但是const用途更广。
2. const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
3. 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。宏的内容直接替换，不计算
4. 宏不能递归 ,但可以嵌套,一个宏内可以出现另一个定义了的宏

## 24、C++11 最常用的新特性

1. auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导
2. nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。
3. 智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。
4. 初始化列表：使用初始化列表来对类进行初始化
5. 右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
6. atomic原子操作用于多线程资源互斥操作
7. 新增STL容器array以及tuple

## 25、C++ 内存的三种分配方式

1. 从静态存储区分配：此时的内存在程序编译的时候已经分配好，并且在程序的整个运行期间都存在。全局变量，static变量等在此存储。
2.  在栈区分配：相关代码执行时创建，执行结束时被自动释放。局部变量在此存储。栈内存分配运算内置于处理器的指令集中，效率高，但容量有限。函数的局部变量，返回值
3. 在堆区分配：动态分配内存。用new/malloc时开辟，delete/free时释放。生存期由用户指定，灵活。但有内存泄露等问题

## 26、堆内存和栈内存的区别

1. 堆空间的内存是动态分配的，一般存放对象，并且需要手动释放内存。
2. 栈空间的内存是由系统自动分配，一般存放局部变量，比如对象的地址等值，不需要程序员对这块内存进行管理，比如，函数中的局部变量的作用范围（生命周期）就是在调完这个函数之后就结束了。

## 27、struct和class的区别

1. 在C++中，可以用struct和class定义类，都可以继承。
2. 区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。
3. 另外，class还可以定义模板类形参，比如template <class T, int i>。

## 28、inline和宏定义的区别

1. 内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接被镶嵌到目标代码中。而宏只是一个简单的替换。
2. 内联函数要做参数类型检查，这是内联函数的优势；
3. 对于短小的代码来说inline增加空间消耗换来的是效率提高，这方面和宏是一模一样的，但是inline在和宏相比没有付出任何额外代价的情况下更安全。
4. 宏是在代码处不加任何验证的简单替代，而内联函数是将代码直接插入调用处，而减少了普通函数调用时的资源消耗。
5. 宏不是函数，只是在编译前（编译预处理阶段）将程序中有关字符串替换成宏体。

## 29、深拷贝和浅拷贝的区别

1. 深拷贝和浅拷贝可以简单的理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝。
2. 在对含有指针成员的对象进行拷贝时，必须要自己定义拷贝构造函数，使拷贝后的对象指针成员有自己的内存空间，即进行深拷贝，这样就避免了内存泄漏发生。
3. 总结：浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。

## 30、构造函数声明为explicit

1. 普通构造函数能被隐式调用，而explicit构造函数只能被显示调用。
2. 不带explicit的优点：可以从构造函数的参数类型向类类型隐式转换
3. 带explicit的优点：任何构造函数（尤其是带一个参数的）都不能隐式地创建类对象
4. 带explicit的缺点：该构造函数只能以直接初始化的形式使用
5. 后的指针是指向两个不同地址的指针。

## 31、构造函数为什么一般不定义为虚函数

虚函数的执行依赖于虚函数表。而虚函数表需要在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。

## 32、构造函数的几种关键字(default delete 0)

1. = default：将拷贝控制成员定义为=default显式要求编译器生成合成的版本。显式缺省(告知编译器生成函数默认的缺省版本)
2. = delete：将拷贝构造函数和拷贝赋值运算符定义删除的函数，阻止拷贝（析构函数不能是删除的函数 C++Primer P450）
3. = 0：将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部