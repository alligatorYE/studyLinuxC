# 嵌入式Linux设备驱动程序开发指南

##  U-Boot的主要特性

###  1. 尺寸小：

   U-Boot是一个引导加载器，也就是说，它在系统里的主要作用是加载操作系统。这就意味着它要实现一些基本功能，但是又不能占用太多的系统资源。典型的例子就是U-Boot存储在相对更小的、更昂贵的NOR闪存中，而操作系统和应用程序存储在更大的、更廉价的NAND闪存中。U-Boot的可用配置（也是有用的）包括基本的交互式命令解释器、支持通过以太网下载文件以及支持对闪存进行编程，它的体积不应超过128 KB。

### 2. 启动快：

   最终用户对运行U-Boot并不感兴趣。在大多数的嵌入式系统里，他们甚至感觉不到U-Boot的存在。通常用户关心的是运行应用程序，期望应用程序在开机后能尽快运行起来。所以在U-Boot中只对需要用到的设备执行初始化，也就是说，除非U-Boot需要通过以太网执行下载文件操作，否则就不要初始化以太网接口，除非U-Boot试图从磁盘或者USB设备中加载文件，否则不要初始化任何磁盘或USB设备。

### 3. 可移植：

   U-Boot不仅是一个引导程序，也是一个工具，可以用于单板启动、生产测试，以及与硬件开发密切相关的活动。到目前为止，它已被移植到大约30个不同处理器系列的数百个不同单板上。

### 4. 可配置：

   U-Boot是一个有非常多实用功能的强大工具。每一个维护者或者使用者必须谨慎决定哪些功能是重要的，哪些功能必须包含在特定的板级配置文件里以满足当前的需求和限制。

### 5. 可调试：

   U-Boot本身不仅仅是一个工具，它也经常被用于硬件初始化启动。所以U-Boot调试通常意味着你不知道是在跟踪U-Boot软件的问题，还是在跟踪运行所用的硬件的问题。简洁易懂的编码和调试功能对每一个人都更加重要。U-Boot的一个重要功能是：在启动阶段能把调试信息及时输出到控制台（通常是串口），即使在调试一些内存相关的功能时也是如此。所有的初始化步骤应该在开始前打印一些类似“开始运行”这样的信息，并在结束时打印“已完成”信息。例如：在开始内存初始化和探测内存大小之前可以打印一条“RAM:”的信息，并且在结束的时候打印“256 MB、n”的字样。这样做的目的是：当问题发生时，你可以实时观察到程序运行到了哪一步。这些功能不仅在软件开发的时候重要，而且在技术支持人员调试硬件问题时同样重要。U-Boot应该支持JTAG调试和BDM调试。它应该使用简单的单进程模式。



## 下面列出组成Linux内核的一些子系统：

> /arch/<arch>：处理器体系结构特有的代码。
/arch/<arch>/<mach>：机器/单板特有的代码。
/Documentation：内核文档。不要错过了（很重要）！
/ipc：进程间通信。
/mm：内存管理。
/fs：文件系统。
/include：内核头文件。
/include/asm-<arch>：处理器体系结构和机器依赖的头文件。
/include/linux：Linux内核核心头文件。
/init：Linux初始化程序（包括main.c）。
/block：块设备驱动代码。
/net：网络协议代码。
/lib：通用的内核库文件。
/kernel：通用的内核代码。
/arch：处理器体系结构特有的代码。
/crypto：加密算法相关代码。
/security：安全机制相关代码。
/drivers：内建的驱动的代码（不包括可选的动态加载驱动模块）。
Makefile：顶层的编译说明文件（设置处理器体系结构和版本）。
/scripts：供内部和外部使用的脚本文件。

## 要确定你的内核版本，请（在命令行）运行：

```bash
$ uname -r
```



## 调用接口和C运行时库

C运行时库（标准C库）定义了宏、类型、字符串处理函数、数学运算函数、输入/输出处理、内存分配和一些与操作系统服务相关的其他功能。运行时库抽象封装了操作系统调用接口，为应用程序提供访问操作系统资源和功能的方法。

目前有好几种C运行时库：glibc、uClibc、eglibc、dietlibc、newlib。必须在交叉编译生成工具链时选择使用哪个C库，因为GCC编译器在编译时要依据特定的C库。

glibc是GNU C库，也是我们在Yocto工程的示例中使用的默认库

#### glibc

glibc和libc都是Linux下的C函数库，libc是Linux下的ANSI C的函数库；glibc是Linux下的GUN C的函数库；GNU C是一种ANSI C的扩展实现。ANSI C是基本的C语言函数库，包含了C语言最基本的库函数。这个库可以根据 头文件划分为 15 个部分，其中包括：

> <asset.h>，<ctype.h>，<errno.h>，<float.h>，<limits.h>，<locale.h>，<math.h>，<setjmp.h> ，<signal.h>，<stdarg.h>，<stddef.h>，<stdlib.h>，<stdio.h>，<string.h>，<time.h>
> 
> <ctype.h>：包含用来测试某个特征字符的函数的函数原型，以及用来转换大小写字母的函数原型；
> 
> <errno.h>：定义用来报告错误条件的宏；
> 
> 浮点常数 (<float.h>)：包含系统的浮点数大小限制；
> 
> 数学常数 (<math.h>)：包含数学库函数的函数原型；
> 
> 标准定义 (<stddef.h>：包含执行某些计算C所用的常见的函数定义；
> 
> 标准 I/O (<stdio.h>)：包含标准输入输出库函数的函数原型，以及他们所用的信息；
> 
> 工具函数 (<stdlib.h>)：包含数字转换到文本以及文本转换到数字的函数原型，还有内存分配、随机数字以及其他实用函数的函数原型；
> 
> 字符串操作 (<string.h>)、：包含字符串处理函数的函数原型；
> 
> 时间和日期 (<time.h>)：包含时间和日期操作的函数原型和类型；
> 
> 可变参数表 (<stdarg.h>)：定义宏，用于处理未知数值和类型的函数的参数列表；
> 
> 信号 (<signal.h>)：包含函数原型和宏，用于处理程序执行期间可能出现的各种条件；
> 
> 非局部跳转 (<setjmp.h>)：包含可以绕过一般函数调用并返回序列的函数的原型；
> 
> 本地信息 (<locale.h>)：包含函数原型和其他信息，使程序可以针对所运行的地区进行修改。地区的表示方法可以使计算机系统处理不同的数据表达约定，如全世界的日期、时间、美元数和大数字
> 
> 程序断言 (<assert.h>) ：包含宏和信息，用于进行诊断，帮助程序调试。这在其他的C语言的IDE中都是有的。

#### uClibc

uClibc 是一个面向[嵌入式](https://so.csdn.net/so/search?q=嵌入式&spm=1001.2101.3001.7020)Linux系统的小型的C标准库。最初uClibc是为了支持uClinux而开发，这是一个不需要内存管理单元（MMU）的Linux版本。uClibc比一般用于Linux发行版的C库GNU C Library (glibc)要小得多， uClibc专注于嵌入式Linux。很多功能可以根据空间需求进行取舍。

#### Newlib

Newlib是一个面向嵌入式系统的C运行库。最初是由Cygnus Solutions收集组装的一个源代码集合，取名为newlib，现在由Red Hat维护，目前的最新的版本是2.1.0。对于与GNU兼容的嵌入式C运行库，Newlib并不是唯一的选择，但是从成熟度来讲，newlib是最优秀的。newlib可移植性强，具有可重入特性、功能完备等特点，已广泛应用于各种嵌入式系统中。Cygwin目前使用Newlib来作为它的C标准库。

#### 其它

##### **1.Glibc**
glibc = GNU C Library
是GNU项（GNU Project）目，所实现的 C语言标准库（C standard library）。
目前，常见的桌面和服务器中的GNU/Linux类的系统中，都是用的这套C语言标准库。
其实现了常见的C库的函数，支持很多种系统平台，功能很全，但是也相对比较臃肿和庞大。

##### **2.uClibc**
一个小型的C语言标准库，主要用于嵌入式。
其最开始设计用于uClinux（注：uClinux不支持MMU），因此比较适用于微处理器中。
对应的，此处的u意思是μ，Micro，微小的意思。

##### uClibc的特点：
(1)uClibc比glibc要小很多。
(2)uClibc是独立的，为了应用于嵌入式系统中，完全重新实现出来的。和glibc在源码结构和二进制上，都不兼容。

##### **3.EGLIBC**
EGLIBC = Embedded GLIBC
EGLIBC是，（后来）glibc的原创作组织FSF所（新）推出的，glibc的一种变体，目的在于将glibc用于嵌入式系统。
EGLIBC的目标是：
(1)保持源码和二进制级别的兼容于Glibc
源代码架构和ABI层面兼容
如果真正实现了这个目标，那意味着，你之前用glibc编译的程序，可以直接用eglibc替换，而不需要重新编译。
这样就可以复用之前的很多的程序了。
(2)降低(内存)资源占用/消耗
(3)使更多的模块为可配置的（以实现按需裁剪不需要的模块）
(4)提高对于交叉编译(cross-compilation)和交叉测试(cross-testing)的支持

Eglibc的最主要特点就是可配置，这样对于嵌入式系统中，你所不需要的模块，比如NIS，locale等，就可以裁剪掉，不把其编译到库中，使得降低生成的库的大小了。

##### **【glibc, uClibc, Elibc的渊源/历史/区别/联系】**

1. 写程序，需要用到很多c语言的库函数。所有的库函数加起来，就是对应的C语言（标准）函数库。
2. 目前在普通GNU/Linux系统中所用的C语言标准库，叫做glibc。其功能很全，函数很多，但是代码太多，编译出来的函数库的大小也很大，即资源占用也很多。
3. 而嵌入式系统中，也需要C语言写代码实现特定功能，也需要用到C语言函数库，但是由于嵌入式系统中，一般资源比较有限，所以不适合直接使用（太占用资源的）gLibc。
4. 所以有人就又（没有参考glibc，而是从头开始，）重新实现了一个用于嵌入式系统中的，代码量不是很大的，资源占用相对较少的，C语言函数库，叫做uClibc。并且，uClibc不支持MMU（内存管理单元）。
5. 而后来，glibc的开发者，又推出个Embedded glibc，简称eglibc，其主要目的也是将glibc用于嵌入式领域。
   相应最大的改动就在于，把更多的库函数，改为可配置的，这样，如果你的嵌入式系统中不需要某些函数，就可以裁剪掉，不把该函数编译到你的eglibc库中，使得最终生成的eglibc库的大小变小，最终符合你的嵌入式系统的要求（不能超过一定的大小），这样，就实现了，把glibc引用于嵌入式系统中的目的了。

可以简单的理解为：
glibc，uClibc，eglibc都是C语言函数库：

6. uClibc是嵌入式系统中用的，glibc是桌面系统用的
7. eglibc也是嵌入式系统中用的，是glibc的嵌入式版本，和glibc在源码和二进制上兼容。
